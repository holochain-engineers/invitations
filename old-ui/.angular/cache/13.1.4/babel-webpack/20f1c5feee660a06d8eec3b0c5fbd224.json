{"ast":null,"code":"import { Observable, Subscription, asapScheduler, ReplaySubject, isObservable, of, scheduled, queueScheduler, throwError, combineLatest, Subject, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, takeUntil, take, map, distinctUntilChanged, shareReplay, tap, catchError } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject } from '@angular/core';\n/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nfunction debounceSync() {\n  return source => new Observable(observer => {\n    let actionSubscription;\n    let actionValue;\n    const rootSubscription = new Subscription();\n    rootSubscription.add(source.subscribe({\n      complete: () => {\n        if (actionSubscription) {\n          observer.next(actionValue);\n        }\n\n        observer.complete();\n      },\n      error: error => {\n        observer.error(error);\n      },\n      next: value => {\n        actionValue = value;\n\n        if (!actionSubscription) {\n          actionSubscription = asapScheduler.schedule(() => {\n            observer.next(actionValue);\n            actionSubscription = undefined;\n          });\n          rootSubscription.add(actionSubscription);\n        }\n      }\n    }));\n    return rootSubscription;\n  });\n}\n\nconst INITIAL_STATE_TOKEN = new InjectionToken('@ngrx/component-store Initial State');\n\nclass ComponentStore {\n  constructor(defaultState) {\n    // Should be used only in ngOnDestroy.\n    this.destroySubject$ = new ReplaySubject(1); // Exposed to any extending Store to be used for the teardown.\n\n    this.destroy$ = this.destroySubject$.asObservable();\n    this.stateSubject$ = new ReplaySubject(1);\n    this.isInitialized = false;\n    this.notInitializedErrorMessage = `${this.constructor.name} has not been initialized yet. ` + `Please make sure it is initialized before updating/getting.`; // Needs to be after destroy$ is declared because it's used in select.\n\n    this.state$ = this.select(s => s); // State can be initialized either through constructor or setState.\n\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n  }\n  /** Completes all relevant Observable streams. */\n\n\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Every time this function is called\n   *     subscribers will be notified of the state change.\n   */\n\n\n  updater(updaterFn) {\n    return observableOrValue => {\n      let initializationError; // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n\n      const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n      const subscription = observable$.pipe(concatMap(value => this.isInitialized ? // Push the value into queueScheduler\n      scheduled([value], queueScheduler).pipe(withLatestFrom(this.stateSubject$)) : // If state was not initialized, we'll throw an error.\n      throwError(() => new Error(this.notInitializedErrorMessage))), takeUntil(this.destroy$)).subscribe({\n        next: ([value, currentState]) => {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.stateSubject$.next(updaterFn(currentState, value));\n        },\n        error: error => {\n          initializationError = error;\n          this.stateSubject$.error(error);\n        }\n      });\n\n      if (initializationError) {\n        // prettier-ignore\n        throw (\n          /** @type {!Error} */\n          initializationError\n        );\n      }\n\n      return subscription;\n    };\n  }\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n\n\n  initState(state) {\n    scheduled([state], queueScheduler).subscribe(s => {\n      this.isInitialized = true;\n      this.stateSubject$.next(s);\n    });\n  }\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n\n\n  setState(stateOrUpdaterFn) {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn)();\n    }\n  }\n  /**\n   * Patches the state with provided partial state.\n   *\n   * @param partialStateOrUpdaterFn a partial state or a partial updater\n   * function that accepts the state and returns the partial state.\n   * @throws Error if the state is not initialized.\n   */\n\n\n  patchState(partialStateOrUpdaterFn) {\n    const patchedState = typeof partialStateOrUpdaterFn === 'function' ? partialStateOrUpdaterFn(this.get()) : partialStateOrUpdaterFn;\n    this.updater((state, partialState) => Object.assign(Object.assign({}, state), partialState))(patchedState);\n  }\n\n  get(projector) {\n    if (!this.isInitialized) {\n      throw new Error(this.notInitializedErrorMessage);\n    }\n\n    let value;\n    this.stateSubject$.pipe(take(1)).subscribe(state => {\n      value = projector ? projector(state) : state;\n    }); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    return value;\n  }\n\n  select(...args) {\n    const {\n      observables,\n      projector,\n      config\n    } = processSelectorArgs(args);\n    let observable$; // If there are no Observables to combine, then we'll just map the value.\n\n    if (observables.length === 0) {\n      observable$ = this.stateSubject$.pipe(config.debounce ? debounceSync() : source$ => source$, map(state => projector(state)));\n    } else {\n      // If there are multiple arguments, then we're aggregating selectors, so we need\n      // to take the combineLatest of them before calling the map function.\n      observable$ = combineLatest(observables).pipe(config.debounce ? debounceSync() : source$ => source$, map(projectorArgs => projector(...projectorArgs)));\n    }\n\n    return observable$.pipe(distinctUntilChanged(), shareReplay({\n      refCount: true,\n      bufferSize: 1\n    }), takeUntil(this.destroy$));\n  }\n  /**\n   * Creates an effect.\n   *\n   * This effect is subscribed to throughout the lifecycle of the ComponentStore.\n   * @param generator A function that takes an origin Observable input and\n   *     returns an Observable. The Observable that is returned will be\n   *     subscribed to for the life of the component.\n   * @return A function that, when called, will trigger the origin Observable.\n   */\n\n\n  effect(generator) {\n    const origin$ = new Subject();\n    generator(origin$) // tied to the lifecycle ðŸ‘‡ of ComponentStore\n    .pipe(takeUntil(this.destroy$)).subscribe();\n    return observableOrValue => {\n      const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n      return observable$.pipe(takeUntil(this.destroy$)).subscribe(value => {\n        // any new ðŸ‘‡ value is pushed into a stream\n        origin$.next(value);\n      });\n    };\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nComponentStore.Éµfac = function ComponentStore_Factory(t) {\n  return new (t || ComponentStore)(i0.ÉµÉµinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nComponentStore.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n  token: ComponentStore,\n  factory: ComponentStore.Éµfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(ComponentStore, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\n\nfunction processSelectorArgs(args) {\n  const selectorArgs = Array.from(args); // Assign default values.\n\n  let config = {\n    debounce: false\n  };\n  let projector; // Last argument is either projector or config\n\n  const projectorOrConfig = selectorArgs.pop();\n\n  if (typeof projectorOrConfig !== 'function') {\n    // We got the config as the last argument, replace any default values with it.\n    config = Object.assign(Object.assign({}, config), projectorOrConfig); // Pop the next args, which would be the projector fn.\n\n    projector = selectorArgs.pop();\n  } else {\n    projector = projectorOrConfig;\n  } // The Observables to combine, if there are any.\n\n\n  const observables = selectorArgs;\n  return {\n    observables,\n    projector,\n    config\n  };\n}\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate.\n * It enforces that the error case is handled and that the effect would still be\n * running should an error occur.\n *\n * Takes an optional third argument for a `complete` callback.\n *\n * ```typescript\n * readonly dismissedAlerts = this.effect<Alert>(alert$ => {\n *  return alert$.pipe(\n *      concatMap(\n *          (alert) => this.alertsService.dismissAlert(alert).pipe(\n *              tapResponse(\n *                 (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *                 (error: { message: string }) => this.logError(error.message),\n *              ))));\n *   });\n * ```\n */\n\n\nfunction tapResponse(nextFn, errorFn, completeFn) {\n  return source => source.pipe(tap({\n    next: nextFn,\n    error: errorFn,\n    complete: completeFn\n  }), catchError(() => EMPTY));\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ComponentStore, INITIAL_STATE_TOKEN, tapResponse };","map":{"version":3,"sources":["/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@ngrx/component-store/fesm2015/ngrx-component-store.mjs"],"names":["Observable","Subscription","asapScheduler","ReplaySubject","isObservable","of","scheduled","queueScheduler","throwError","combineLatest","Subject","EMPTY","concatMap","withLatestFrom","takeUntil","take","map","distinctUntilChanged","shareReplay","tap","catchError","i0","InjectionToken","Injectable","Optional","Inject","debounceSync","source","observer","actionSubscription","actionValue","rootSubscription","add","subscribe","complete","next","error","value","schedule","undefined","INITIAL_STATE_TOKEN","ComponentStore","constructor","defaultState","destroySubject$","destroy$","asObservable","stateSubject$","isInitialized","notInitializedErrorMessage","name","state$","select","s","initState","ngOnDestroy","updater","updaterFn","observableOrValue","initializationError","observable$","subscription","pipe","Error","currentState","state","setState","stateOrUpdaterFn","patchState","partialStateOrUpdaterFn","patchedState","get","partialState","Object","assign","projector","args","observables","config","processSelectorArgs","length","debounce","source$","projectorArgs","refCount","bufferSize","effect","generator","origin$","Éµfac","Éµprov","type","decorators","selectorArgs","Array","from","projectorOrConfig","pop","tapResponse","nextFn","errorFn","completeFn"],"mappings":"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","sourcesContent":["import { Observable, Subscription, asapScheduler, ReplaySubject, isObservable, of, scheduled, queueScheduler, throwError, combineLatest, Subject, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, takeUntil, take, map, distinctUntilChanged, shareReplay, tap, catchError } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject } from '@angular/core';\n\n/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nfunction debounceSync() {\n    return (source) => new Observable((observer) => {\n        let actionSubscription;\n        let actionValue;\n        const rootSubscription = new Subscription();\n        rootSubscription.add(source.subscribe({\n            complete: () => {\n                if (actionSubscription) {\n                    observer.next(actionValue);\n                }\n                observer.complete();\n            },\n            error: (error) => {\n                observer.error(error);\n            },\n            next: (value) => {\n                actionValue = value;\n                if (!actionSubscription) {\n                    actionSubscription = asapScheduler.schedule(() => {\n                        observer.next(actionValue);\n                        actionSubscription = undefined;\n                    });\n                    rootSubscription.add(actionSubscription);\n                }\n            },\n        }));\n        return rootSubscription;\n    });\n}\n\nconst INITIAL_STATE_TOKEN = new InjectionToken('@ngrx/component-store Initial State');\nclass ComponentStore {\n    constructor(defaultState) {\n        // Should be used only in ngOnDestroy.\n        this.destroySubject$ = new ReplaySubject(1);\n        // Exposed to any extending Store to be used for the teardown.\n        this.destroy$ = this.destroySubject$.asObservable();\n        this.stateSubject$ = new ReplaySubject(1);\n        this.isInitialized = false;\n        this.notInitializedErrorMessage = `${this.constructor.name} has not been initialized yet. ` +\n            `Please make sure it is initialized before updating/getting.`;\n        // Needs to be after destroy$ is declared because it's used in select.\n        this.state$ = this.select((s) => s);\n        // State can be initialized either through constructor or setState.\n        if (defaultState) {\n            this.initState(defaultState);\n        }\n    }\n    /** Completes all relevant Observable streams. */\n    ngOnDestroy() {\n        this.stateSubject$.complete();\n        this.destroySubject$.next();\n    }\n    /**\n     * Creates an updater.\n     *\n     * Throws an error if updater is called with synchronous values (either\n     * imperative value or Observable that is synchronous) before ComponentStore\n     * is initialized. If called with async Observable before initialization then\n     * state will not be updated and subscription would be closed.\n     *\n     * @param updaterFn A static updater function that takes 2 parameters (the\n     * current state and an argument object) and returns a new instance of the\n     * state.\n     * @return A function that accepts one argument which is forwarded as the\n     *     second argument to `updaterFn`. Every time this function is called\n     *     subscribers will be notified of the state change.\n     */\n    updater(updaterFn) {\n        return ((observableOrValue) => {\n            let initializationError;\n            // We can receive either the value or an observable. In case it's a\n            // simple value, we'll wrap it with `of` operator to turn it into\n            // Observable.\n            const observable$ = isObservable(observableOrValue)\n                ? observableOrValue\n                : of(observableOrValue);\n            const subscription = observable$\n                .pipe(concatMap((value) => this.isInitialized\n                ? // Push the value into queueScheduler\n                    scheduled([value], queueScheduler).pipe(withLatestFrom(this.stateSubject$))\n                : // If state was not initialized, we'll throw an error.\n                    throwError(() => new Error(this.notInitializedErrorMessage))), takeUntil(this.destroy$))\n                .subscribe({\n                next: ([value, currentState]) => {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.stateSubject$.next(updaterFn(currentState, value));\n                },\n                error: (error) => {\n                    initializationError = error;\n                    this.stateSubject$.error(error);\n                },\n            });\n            if (initializationError) {\n                // prettier-ignore\n                throw /** @type {!Error} */ (initializationError);\n            }\n            return subscription;\n        });\n    }\n    /**\n     * Initializes state. If it was already initialized then it resets the\n     * state.\n     */\n    initState(state) {\n        scheduled([state], queueScheduler).subscribe((s) => {\n            this.isInitialized = true;\n            this.stateSubject$.next(s);\n        });\n    }\n    /**\n     * Sets the state specific value.\n     * @param stateOrUpdaterFn object of the same type as the state or an\n     * updaterFn, returning such object.\n     */\n    setState(stateOrUpdaterFn) {\n        if (typeof stateOrUpdaterFn !== 'function') {\n            this.initState(stateOrUpdaterFn);\n        }\n        else {\n            this.updater(stateOrUpdaterFn)();\n        }\n    }\n    /**\n     * Patches the state with provided partial state.\n     *\n     * @param partialStateOrUpdaterFn a partial state or a partial updater\n     * function that accepts the state and returns the partial state.\n     * @throws Error if the state is not initialized.\n     */\n    patchState(partialStateOrUpdaterFn) {\n        const patchedState = typeof partialStateOrUpdaterFn === 'function'\n            ? partialStateOrUpdaterFn(this.get())\n            : partialStateOrUpdaterFn;\n        this.updater((state, partialState) => (Object.assign(Object.assign({}, state), partialState)))(patchedState);\n    }\n    get(projector) {\n        if (!this.isInitialized) {\n            throw new Error(this.notInitializedErrorMessage);\n        }\n        let value;\n        this.stateSubject$.pipe(take(1)).subscribe((state) => {\n            value = projector ? projector(state) : state;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return value;\n    }\n    select(...args) {\n        const { observables, projector, config } = processSelectorArgs(args);\n        let observable$;\n        // If there are no Observables to combine, then we'll just map the value.\n        if (observables.length === 0) {\n            observable$ = this.stateSubject$.pipe(config.debounce ? debounceSync() : (source$) => source$, map((state) => projector(state)));\n        }\n        else {\n            // If there are multiple arguments, then we're aggregating selectors, so we need\n            // to take the combineLatest of them before calling the map function.\n            observable$ = combineLatest(observables).pipe(config.debounce ? debounceSync() : (source$) => source$, map((projectorArgs) => projector(...projectorArgs)));\n        }\n        return observable$.pipe(distinctUntilChanged(), shareReplay({\n            refCount: true,\n            bufferSize: 1,\n        }), takeUntil(this.destroy$));\n    }\n    /**\n     * Creates an effect.\n     *\n     * This effect is subscribed to throughout the lifecycle of the ComponentStore.\n     * @param generator A function that takes an origin Observable input and\n     *     returns an Observable. The Observable that is returned will be\n     *     subscribed to for the life of the component.\n     * @return A function that, when called, will trigger the origin Observable.\n     */\n    effect(generator) {\n        const origin$ = new Subject();\n        generator(origin$)\n            // tied to the lifecycle ðŸ‘‡ of ComponentStore\n            .pipe(takeUntil(this.destroy$))\n            .subscribe();\n        return ((observableOrValue) => {\n            const observable$ = isObservable(observableOrValue)\n                ? observableOrValue\n                : of(observableOrValue);\n            return observable$.pipe(takeUntil(this.destroy$)).subscribe((value) => {\n                // any new ðŸ‘‡ value is pushed into a stream\n                origin$.next(value);\n            });\n        });\n    }\n}\n/** @nocollapse */ /** @nocollapse */ ComponentStore.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ComponentStore, deps: [{ token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ÉµÉµFactoryTarget.Injectable });\n/** @nocollapse */ /** @nocollapse */ ComponentStore.Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ComponentStore });\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ComponentStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [INITIAL_STATE_TOKEN]\n                    }] }];\n    } });\nfunction processSelectorArgs(args) {\n    const selectorArgs = Array.from(args);\n    // Assign default values.\n    let config = { debounce: false };\n    let projector;\n    // Last argument is either projector or config\n    const projectorOrConfig = selectorArgs.pop();\n    if (typeof projectorOrConfig !== 'function') {\n        // We got the config as the last argument, replace any default values with it.\n        config = Object.assign(Object.assign({}, config), projectorOrConfig);\n        // Pop the next args, which would be the projector fn.\n        projector = selectorArgs.pop();\n    }\n    else {\n        projector = projectorOrConfig;\n    }\n    // The Observables to combine, if there are any.\n    const observables = selectorArgs;\n    return {\n        observables,\n        projector,\n        config,\n    };\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate.\n * It enforces that the error case is handled and that the effect would still be\n * running should an error occur.\n *\n * Takes an optional third argument for a `complete` callback.\n *\n * ```typescript\n * readonly dismissedAlerts = this.effect<Alert>(alert$ => {\n *  return alert$.pipe(\n *      concatMap(\n *          (alert) => this.alertsService.dismissAlert(alert).pipe(\n *              tapResponse(\n *                 (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *                 (error: { message: string }) => this.logError(error.message),\n *              ))));\n *   });\n * ```\n */\nfunction tapResponse(nextFn, errorFn, completeFn) {\n    return (source) => source.pipe(tap({\n        next: nextFn,\n        error: errorFn,\n        complete: completeFn,\n    }), catchError(() => EMPTY));\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentStore, INITIAL_STATE_TOKEN, tapResponse };\n"]},"metadata":{},"sourceType":"module"}