{"ast":null,"code":"import _asyncToGenerator from \"/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ComponentStore } from '@ngrx/component-store';\nimport { Subscription } from 'rxjs';\nimport { tap, withLatestFrom } from 'rxjs/operators';\nimport { InvitationService } from '../services/invitation.service';\nimport { environment } from '@environment';\nimport * as i0 from \"@angular/core\"; //TODO : make the ComponentStore composition based so we can dynamically create new stores for cell clones\n\nexport class InvitationStore extends ComponentStore {\n  constructor(injector) {\n    super({\n      invitations: []\n    });\n    this.injector = injector;\n    this._subs = new Subscription();\n    this._cell = environment.cell1;\n    /* updaters */\n\n    this.addInvitation = this.updater((state, invitation) => ({\n      invitations: [...state.invitations, invitation]\n    }));\n    this.updateInvitation = this.updater((state, invitation) => ({\n      invitations: [...state.invitations.filter(entry => {\n        return entry.invitation_entry_hash !== invitation.invitation_entry_hash; //? undefined : entry\n      }), invitation]\n    }));\n    this.loadInvitations = this.updater((state, invitations) => Object.assign(Object.assign({}, state), {\n      invitations: invitations || []\n    })); // effects (handles and serializes signals from the holochain network)\n\n    this.setInvitations = this.effect(invite$ => invite$.pipe(withLatestFrom(this.selectInvitations()), tap(([invite, invitations]) => {\n      const id = invite.invitation_entry_hash;\n      const index = invitations.findIndex(cur => {\n        //console.log('compare', cur, id, cur.invitation_entry_hash === id);\n        return cur.invitation_entry_hash === id;\n      });\n\n      if (index > -1) {\n        const modifiedInvitations = [...invitations];\n        modifiedInvitations[index] = invite;\n        this.loadInvitations(modifiedInvitations);\n      } else {\n        console.debug(\"adding invite:\", invite);\n        this.updateInvitation(invite);\n      }\n    })));\n    this._invitationService = new InvitationService(injector, this._cell); //we create a zome service instance for each cell+zome\n\n    this._subs.add(this._invitationService.invitationsReceived$.subscribe({\n      next: invitationEntryInfo => {\n        console.log('Invitation received:', invitationEntryInfo);\n        this.setInvitations(invitationEntryInfo);\n      },\n      error: error => {\n        console.error('An error happened while updating Invitation:', error);\n      }\n    }));\n\n    this._subs.add(this._invitationService.invitationsAccepted$.subscribe({\n      next: invitationEntryInfo => {\n        this.setInvitations(invitationEntryInfo);\n      },\n      error: error => {\n        console.error('An error happened while updating Invitation:', error);\n      }\n    }));\n\n    this._subs.add(this._invitationService.invitationsRejected$.subscribe({\n      next: invitationEntryInfo => {\n        ///this.setEditedInvitation(invitationEntryInfo!)\n        this.setInvitations(invitationEntryInfo); //this.clearEditedInvitation();\n      },\n      error: error => {\n        console.error('An error happened while updating Invitation:', error);\n      }\n    }));\n  }\n  /* selectors */\n\n\n  selectInvitation(hash) {\n    return this.select(state => state.invitations.find(i => i.invitation_header_hash === hash));\n  }\n\n  selectInvitations() {\n    return this.select(({\n      invitations\n    }) => invitations);\n  }\n\n  selectCompletedInvitations() {\n    return this.select(state => state.invitations.filter(inv => JSON.stringify(inv.invitation.invitees) === JSON.stringify(inv.invitees_who_accepted)));\n  }\n\n  selectUncompletedInvitations() {\n    return this.select(state => state.invitations.filter(inv => JSON.stringify(inv.invitation.invitees) !== JSON.stringify(inv.invitees_who_accepted)));\n  }\n\n  ngOnDestroy() {\n    this._subs.unsubscribe();\n  }\n  /* call zome functions */\n\n\n  sendNewInvitation(agentPubKeyB64_arr) {\n    console.debug(\"new invite:\", agentPubKeyB64_arr);\n\n    this._invitationService.sendInvitation(agentPubKeyB64_arr);\n  }\n\n  acceptInvitation(header_hash) {\n    this._invitationService.acceptInvitation(header_hash);\n  }\n\n  rejectInvitation(header_hash) {\n    this._invitationService.rejectInvitation(header_hash);\n  }\n\n  clearInvitation(header_hash) {\n    this._invitationService.clearInvitation(header_hash);\n  } //TODO this should be an Effect \n\n\n  loadInvitationEntries() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const invitations = yield _this._invitationService.getMyPendingInvitations();\n      console.debug(\"invitations:\", invitations);\n\n      _this.loadInvitations(invitations);\n    })();\n  }\n\n  getNetStatus() {\n    return this._invitationService.getNetworkStatus();\n  }\n\n}\n\nInvitationStore.ɵfac = function InvitationStore_Factory(t) {\n  return new (t || InvitationStore)(i0.ɵɵinject(i0.Injector));\n};\n\nInvitationStore.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InvitationStore,\n  factory: InvitationStore.ɵfac\n});","map":{"version":3,"sources":["/Users/futorine/dev/holochain/holochain-engineers/team-mates/ui/src/app/store/invitation.store.ts"],"names":["ComponentStore","Subscription","tap","withLatestFrom","InvitationService","environment","i0","InvitationStore","constructor","injector","invitations","_subs","_cell","cell1","addInvitation","updater","state","invitation","updateInvitation","filter","entry","invitation_entry_hash","loadInvitations","Object","assign","setInvitations","effect","invite$","pipe","selectInvitations","invite","id","index","findIndex","cur","modifiedInvitations","console","debug","_invitationService","add","invitationsReceived$","subscribe","next","invitationEntryInfo","log","error","invitationsAccepted$","invitationsRejected$","selectInvitation","hash","select","find","i","invitation_header_hash","selectCompletedInvitations","inv","JSON","stringify","invitees","invitees_who_accepted","selectUncompletedInvitations","ngOnDestroy","unsubscribe","sendNewInvitation","agentPubKeyB64_arr","sendInvitation","acceptInvitation","header_hash","rejectInvitation","clearInvitation","loadInvitationEntries","getMyPendingInvitations","getNetStatus","getNetworkStatus","ɵfac","InvitationStore_Factory","t","ɵɵinject","Injector","ɵprov","ɵɵdefineInjectable","token","factory"],"mappings":"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","sourcesContent":["import { ComponentStore } from '@ngrx/component-store';\nimport { Subscription } from 'rxjs';\nimport { tap, withLatestFrom } from 'rxjs/operators';\nimport { InvitationService } from '../services/invitation.service';\nimport { environment } from '@environment';\nimport * as i0 from \"@angular/core\";\n//TODO : make the ComponentStore composition based so we can dynamically create new stores for cell clones\nexport class InvitationStore extends ComponentStore {\n    constructor(injector) {\n        super({ invitations: [] });\n        this.injector = injector;\n        this._subs = new Subscription();\n        this._cell = environment.cell1;\n        /* updaters */\n        this.addInvitation = this.updater((state, invitation) => ({\n            invitations: [...state.invitations, invitation],\n        }));\n        this.updateInvitation = this.updater((state, invitation) => ({\n            invitations: [...state.invitations.filter((entry) => {\n                    return entry.invitation_entry_hash !== invitation.invitation_entry_hash; //? undefined : entry\n                }), invitation]\n        }));\n        this.loadInvitations = this.updater((state, invitations) => (Object.assign(Object.assign({}, state), { invitations: invitations || [] })));\n        // effects (handles and serializes signals from the holochain network)\n        this.setInvitations = this.effect((invite$) => invite$.pipe(withLatestFrom(this.selectInvitations()), tap(([invite, invitations]) => {\n            const id = invite.invitation_entry_hash;\n            const index = invitations.findIndex((cur) => {\n                //console.log('compare', cur, id, cur.invitation_entry_hash === id);\n                return cur.invitation_entry_hash === id;\n            });\n            if (index > -1) {\n                const modifiedInvitations = [...invitations];\n                modifiedInvitations[index] = invite;\n                this.loadInvitations(modifiedInvitations);\n            }\n            else {\n                console.debug(\"adding invite:\", invite);\n                this.updateInvitation(invite);\n            }\n        })));\n        this._invitationService = new InvitationService(injector, this._cell); //we create a zome service instance for each cell+zome\n        this._subs.add(this._invitationService.invitationsReceived$.subscribe({\n            next: (invitationEntryInfo) => {\n                console.log('Invitation received:', invitationEntryInfo);\n                this.setInvitations(invitationEntryInfo);\n            },\n            error: (error) => {\n                console.error('An error happened while updating Invitation:', error);\n            },\n        }));\n        this._subs.add(this._invitationService.invitationsAccepted$.subscribe({\n            next: (invitationEntryInfo) => {\n                this.setInvitations(invitationEntryInfo);\n            },\n            error: (error) => {\n                console.error('An error happened while updating Invitation:', error);\n            },\n        }));\n        this._subs.add(this._invitationService.invitationsRejected$.subscribe({\n            next: (invitationEntryInfo) => {\n                ///this.setEditedInvitation(invitationEntryInfo!)\n                this.setInvitations(invitationEntryInfo);\n                //this.clearEditedInvitation();\n            },\n            error: (error) => {\n                console.error('An error happened while updating Invitation:', error);\n            },\n        }));\n    }\n    /* selectors */\n    selectInvitation(hash) {\n        return this.select((state) => state.invitations.find(i => i.invitation_header_hash === hash));\n    }\n    selectInvitations() {\n        return this.select(({ invitations }) => invitations);\n    }\n    selectCompletedInvitations() {\n        return this.select((state) => state.invitations.filter(inv => JSON.stringify(inv.invitation.invitees) === JSON.stringify(inv.invitees_who_accepted)));\n    }\n    selectUncompletedInvitations() {\n        return this.select((state) => state.invitations.filter(inv => JSON.stringify(inv.invitation.invitees) !== JSON.stringify(inv.invitees_who_accepted)));\n    }\n    ngOnDestroy() {\n        this._subs.unsubscribe();\n    }\n    /* call zome functions */\n    sendNewInvitation(agentPubKeyB64_arr) {\n        console.debug(\"new invite:\", agentPubKeyB64_arr);\n        this._invitationService.sendInvitation(agentPubKeyB64_arr);\n    }\n    acceptInvitation(header_hash) {\n        this._invitationService.acceptInvitation(header_hash);\n    }\n    rejectInvitation(header_hash) {\n        this._invitationService.rejectInvitation(header_hash);\n    }\n    clearInvitation(header_hash) {\n        this._invitationService.clearInvitation(header_hash);\n    }\n    //TODO this should be an Effect \n    async loadInvitationEntries() {\n        const invitations = await this._invitationService.getMyPendingInvitations();\n        console.debug(\"invitations:\", invitations);\n        this.loadInvitations(invitations);\n    }\n    getNetStatus() {\n        return this._invitationService.getNetworkStatus();\n    }\n}\nInvitationStore.ɵfac = function InvitationStore_Factory(t) { return new (t || InvitationStore)(i0.ɵɵinject(i0.Injector)); };\nInvitationStore.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: InvitationStore, factory: InvitationStore.ɵfac });\n"]},"metadata":{},"sourceType":"module"}