{"ast":null,"code":"import _asyncToGenerator from \"/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode } from \"@msgpack/msgpack\";\n\nconst readAppBundleFromPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path) {\n    const isBrowser = typeof window !== \"undefined\";\n\n    if (isBrowser) {\n      throw new Error(\"Cannot read app bundle from path in browser context\");\n    }\n\n    const {\n      promises: {\n        readFile\n      }\n    } = yield import(\"fs\");\n    const {\n      gunzip\n    } = yield import(\"zlib\");\n    const compressed = yield readFile(path);\n    const encoded = yield new Promise((resolve, reject) => gunzip(compressed, (err, bytes) => err === null ? resolve(bytes) : reject(err)));\n    return decode(encoded);\n  });\n\n  return function readAppBundleFromPath(_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); /// Adds properties to app bundle. Requires node if passed a path.\n\n\nexport const appBundleWithProperties = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (source, properties) {\n    const originalBundle = \"path\" in source ? yield readAppBundleFromPath(source.path) : source.bundle;\n    return {\n      bundle: { ...originalBundle,\n        manifest: { ...originalBundle.manifest,\n          roles: originalBundle.manifest.roles.map(roleManifest => ({ ...roleManifest,\n            dna: { ...roleManifest.dna,\n              properties: properties[roleManifest.id]\n            }\n          }))\n        }\n      }\n    };\n  });\n\n  return function appBundleWithProperties(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@holochain/client/lib/bundle.js"],"names":["decode","readAppBundleFromPath","path","isBrowser","window","Error","promises","readFile","gunzip","compressed","encoded","Promise","resolve","reject","err","bytes","appBundleWithProperties","source","properties","originalBundle","bundle","manifest","roles","map","roleManifest","dna","id"],"mappings":";AAAA,SAASA,MAAT,QAAuB,kBAAvB;;AACA,MAAMC,qBAAqB;AAAA,+BAAG,WAAOC,IAAP,EAAgB;AAC1C,UAAMC,SAAS,GAAG,OAAOC,MAAP,KAAkB,WAApC;;AACA,QAAID,SAAJ,EAAe;AACX,YAAM,IAAIE,KAAJ,CAAU,qDAAV,CAAN;AACH;;AACD,UAAM;AAAEC,MAAAA,QAAQ,EAAE;AAAEC,QAAAA;AAAF;AAAZ,cAAoC,OAAO,IAAP,CAA1C;AACA,UAAM;AAAEC,MAAAA;AAAF,cAAmB,OAAO,MAAP,CAAzB;AACA,UAAMC,UAAU,SAASF,QAAQ,CAACL,IAAD,CAAjC;AACA,UAAMQ,OAAO,SAAS,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqBL,MAAM,CAACC,UAAD,EAAa,CAACK,GAAD,EAAMC,KAAN,KAAgBD,GAAG,KAAK,IAAR,GAAeF,OAAO,CAACG,KAAD,CAAtB,GAAgCF,MAAM,CAACC,GAAD,CAAnE,CAAvC,CAAtB;AACA,WAAOd,MAAM,CAACU,OAAD,CAAb;AACH,GAV0B;;AAAA,kBAArBT,qBAAqB;AAAA;AAAA;AAAA,GAA3B,C,CAWA;;;AACA,OAAO,MAAMe,uBAAuB;AAAA,gCAAG,WAAOC,MAAP,EAAeC,UAAf,EAA8B;AACjE,UAAMC,cAAc,GAAG,UAAUF,MAAV,SAAyBhB,qBAAqB,CAACgB,MAAM,CAACf,IAAR,CAA9C,GAA8De,MAAM,CAACG,MAA5F;AACA,WAAO;AACHA,MAAAA,MAAM,EAAE,EACJ,GAAGD,cADC;AAEJE,QAAAA,QAAQ,EAAE,EACN,GAAGF,cAAc,CAACE,QADZ;AAENC,UAAAA,KAAK,EAAEH,cAAc,CAACE,QAAf,CAAwBC,KAAxB,CAA8BC,GAA9B,CAAmCC,YAAD,KAAmB,EACxD,GAAGA,YADqD;AAExDC,YAAAA,GAAG,EAAE,EACD,GAAGD,YAAY,CAACC,GADf;AAEDP,cAAAA,UAAU,EAAEA,UAAU,CAACM,YAAY,CAACE,EAAd;AAFrB;AAFmD,WAAnB,CAAlC;AAFD;AAFN;AADL,KAAP;AAeH,GAjBmC;;AAAA,kBAAvBV,uBAAuB;AAAA;AAAA;AAAA,GAA7B","sourcesContent":["import { decode } from \"@msgpack/msgpack\";\nconst readAppBundleFromPath = async (path) => {\n    const isBrowser = typeof window !== \"undefined\";\n    if (isBrowser) {\n        throw new Error(\"Cannot read app bundle from path in browser context\");\n    }\n    const { promises: { readFile }, } = await import(\"fs\");\n    const { gunzip } = await import(\"zlib\");\n    const compressed = await readFile(path);\n    const encoded = await new Promise((resolve, reject) => gunzip(compressed, (err, bytes) => err === null ? resolve(bytes) : reject(err)));\n    return decode(encoded);\n};\n/// Adds properties to app bundle. Requires node if passed a path.\nexport const appBundleWithProperties = async (source, properties) => {\n    const originalBundle = \"path\" in source ? await readAppBundleFromPath(source.path) : source.bundle;\n    return {\n        bundle: {\n            ...originalBundle,\n            manifest: {\n                ...originalBundle.manifest,\n                roles: originalBundle.manifest.roles.map((roleManifest) => ({\n                    ...roleManifest,\n                    dna: {\n                        ...roleManifest.dna,\n                        properties: properties[roleManifest.id],\n                    },\n                })),\n            },\n        },\n    };\n};\n"]},"metadata":{},"sourceType":"module"}