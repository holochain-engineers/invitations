{"ast":null,"code":"import _asyncToGenerator from \"/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nconst ERROR_TYPE = \"error\";\nexport const DEFAULT_TIMEOUT = 15000;\n/**\n * Take a Requester function which deals with tagged requests and responses,\n * and return a Requester which deals only with the inner data types, also\n * with the optional Transformer applied to further modify the input and output.\n */\n\nexport const requesterTransformer = (requester, tag, transform = identityTransformer) => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (req, timeout) {\n    const input = {\n      type: tag,\n      data: transform.input(req)\n    };\n    const response = yield requester(input, timeout);\n    const output = transform.output(response.data);\n    return output;\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst identity = x => x;\n\nconst identityTransformer = {\n  input: identity,\n  output: identity\n};\nexport const catchError = res => {\n  return res.type === ERROR_TYPE ? Promise.reject(res) : Promise.resolve(res);\n};\nexport const promiseTimeout = (promise, tag, ms) => {\n  let id;\n  const timeout = new Promise((_, reject) => {\n    id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(`Timed out in ${ms}ms: ${tag}`));\n    }, ms);\n  });\n  return new Promise((res, rej) => {\n    Promise.race([promise, timeout]).then(a => {\n      clearTimeout(id);\n      return res(a);\n    }).catch(e => {\n      return rej(e);\n    });\n  });\n};","map":{"version":3,"sources":["/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@holochain/client/lib/api/common.js"],"names":["ERROR_TYPE","DEFAULT_TIMEOUT","requesterTransformer","requester","tag","transform","identityTransformer","req","timeout","input","type","data","response","output","identity","x","catchError","res","Promise","reject","resolve","promiseTimeout","promise","ms","id","_","setTimeout","clearTimeout","Error","rej","race","then","a","catch","e"],"mappings":";AAAA,MAAMA,UAAU,GAAG,OAAnB;AACA,OAAO,MAAMC,eAAe,GAAG,KAAxB;AACP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,oBAAoB,GAAG,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,SAAS,GAAGC,mBAA7B;AAAA,+BAAqD,WAAOC,GAAP,EAAYC,OAAZ,EAAwB;AAC7G,UAAMC,KAAK,GAAG;AAAEC,MAAAA,IAAI,EAAEN,GAAR;AAAaO,MAAAA,IAAI,EAAEN,SAAS,CAACI,KAAV,CAAgBF,GAAhB;AAAnB,KAAd;AACA,UAAMK,QAAQ,SAAST,SAAS,CAACM,KAAD,EAAQD,OAAR,CAAhC;AACA,UAAMK,MAAM,GAAGR,SAAS,CAACQ,MAAV,CAAiBD,QAAQ,CAACD,IAA1B,CAAf;AACA,WAAOE,MAAP;AACH,GALmC;;AAAA;AAAA;AAAA;AAAA,GAA7B;;AAMP,MAAMC,QAAQ,GAAIC,CAAD,IAAOA,CAAxB;;AACA,MAAMT,mBAAmB,GAAG;AACxBG,EAAAA,KAAK,EAAEK,QADiB;AAExBD,EAAAA,MAAM,EAAEC;AAFgB,CAA5B;AAIA,OAAO,MAAME,UAAU,GAAIC,GAAD,IAAS;AAC/B,SAAOA,GAAG,CAACP,IAAJ,KAAaV,UAAb,GAA0BkB,OAAO,CAACC,MAAR,CAAeF,GAAf,CAA1B,GAAgDC,OAAO,CAACE,OAAR,CAAgBH,GAAhB,CAAvD;AACH,CAFM;AAGP,OAAO,MAAMI,cAAc,GAAG,CAACC,OAAD,EAAUlB,GAAV,EAAemB,EAAf,KAAsB;AAChD,MAAIC,EAAJ;AACA,QAAMhB,OAAO,GAAG,IAAIU,OAAJ,CAAY,CAACO,CAAD,EAAIN,MAAJ,KAAe;AACvCK,IAAAA,EAAE,GAAGE,UAAU,CAAC,MAAM;AAClBC,MAAAA,YAAY,CAACH,EAAD,CAAZ;AACAL,MAAAA,MAAM,CAAC,IAAIS,KAAJ,CAAW,gBAAeL,EAAG,OAAMnB,GAAI,EAAvC,CAAD,CAAN;AACH,KAHc,EAGZmB,EAHY,CAAf;AAIH,GALe,CAAhB;AAMA,SAAO,IAAIL,OAAJ,CAAY,CAACD,GAAD,EAAMY,GAAN,KAAc;AAC7BX,IAAAA,OAAO,CAACY,IAAR,CAAa,CAACR,OAAD,EAAUd,OAAV,CAAb,EACKuB,IADL,CACWC,CAAD,IAAO;AACbL,MAAAA,YAAY,CAACH,EAAD,CAAZ;AACA,aAAOP,GAAG,CAACe,CAAD,CAAV;AACH,KAJD,EAKKC,KALL,CAKYC,CAAD,IAAO;AACd,aAAOL,GAAG,CAACK,CAAD,CAAV;AACH,KAPD;AAQH,GATM,CAAP;AAUH,CAlBM","sourcesContent":["const ERROR_TYPE = \"error\";\nexport const DEFAULT_TIMEOUT = 15000;\n/**\n * Take a Requester function which deals with tagged requests and responses,\n * and return a Requester which deals only with the inner data types, also\n * with the optional Transformer applied to further modify the input and output.\n */\nexport const requesterTransformer = (requester, tag, transform = identityTransformer) => async (req, timeout) => {\n    const input = { type: tag, data: transform.input(req) };\n    const response = await requester(input, timeout);\n    const output = transform.output(response.data);\n    return output;\n};\nconst identity = (x) => x;\nconst identityTransformer = {\n    input: identity,\n    output: identity,\n};\nexport const catchError = (res) => {\n    return res.type === ERROR_TYPE ? Promise.reject(res) : Promise.resolve(res);\n};\nexport const promiseTimeout = (promise, tag, ms) => {\n    let id;\n    const timeout = new Promise((_, reject) => {\n        id = setTimeout(() => {\n            clearTimeout(id);\n            reject(new Error(`Timed out in ${ms}ms: ${tag}`));\n        }, ms);\n    });\n    return new Promise((res, rej) => {\n        Promise.race([promise, timeout])\n            .then((a) => {\n            clearTimeout(id);\n            return res(a);\n        })\n            .catch((e) => {\n            return rej(e);\n        });\n    });\n};\n"]},"metadata":{},"sourceType":"module"}