{"ast":null,"code":"import _asyncToGenerator from \"/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode, encode } from \"@msgpack/msgpack\";\nimport Websocket from \"isomorphic-ws\";\n/**\n * A Websocket client which can make requests and receive responses,\n * as well as send and receive signals\n *\n * Uses Holochain's websocket WireMessage for communication.\n */\n\nexport class WsClient {\n  socket;\n  pendingRequests;\n  index;\n  alreadyWarnedNoSignalCb;\n\n  constructor(socket, signalCb) {\n    var _this = this;\n\n    this.socket = socket;\n    this.pendingRequests = {};\n    this.index = 0; // TODO: allow adding signal handlers later\n\n    this.alreadyWarnedNoSignalCb = false;\n\n    socket.onmessage = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (encodedMsg) {\n        let data = encodedMsg.data; // If data is not a buffer (nodejs), it will be a blob (browser)\n\n        if (typeof Buffer === \"undefined\" || !Buffer.isBuffer(data)) {\n          data = yield data.arrayBuffer();\n        }\n\n        const msg = decode(data);\n\n        if (msg.type === \"Signal\") {\n          if (signalCb) {\n            const decodedMessage = decode(msg.data);\n\n            if (!decodedMessage.App) {\n              // We have received a system signal, do nothing\n              return;\n            } // Note: holochain currently returns signals as an array of two values: cellId and the serialized signal payload\n            // and this array is nested within the App key within the returned message.\n\n\n            const decodedCellId = decodedMessage.App[0]; // Note:In order to return readible content to the UI, the signal payload must also be decoded.\n\n            const decodedPayload = signalTransform(decodedMessage.App[1]); // Return a uniform format to UI (ie: { type, data } - the same format as with callZome and appInfo...)\n\n            const signal = {\n              type: msg.type,\n              data: {\n                cellId: decodedCellId,\n                payload: decodedPayload\n              }\n            };\n            signalCb(signal);\n          } else {\n            if (!_this.alreadyWarnedNoSignalCb) console.log(\"Received signal but no signal callback was set in constructor\");\n            _this.alreadyWarnedNoSignalCb = true;\n          }\n        } else if (msg.type === \"Response\") {\n          _this.handleResponse(msg);\n        } else {\n          console.error(`Got unrecognized Websocket message type: ${msg.type}`);\n        }\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n\n  emitSignal(data) {\n    const encodedMsg = encode({\n      type: \"Signal\",\n      data: encode(data)\n    });\n    this.socket.send(encodedMsg);\n  }\n\n  request(data) {\n    const id = this.index;\n    this.index += 1;\n    const encodedMsg = encode({\n      id,\n      type: \"Request\",\n      data: encode(data)\n    });\n    const promise = new Promise((fulfill, reject) => {\n      this.pendingRequests[id] = {\n        fulfill,\n        reject\n      };\n    });\n\n    if (this.socket.readyState === this.socket.OPEN) {\n      this.socket.send(encodedMsg);\n    } else {\n      return Promise.reject(new Error(\"Socket is not open\"));\n    }\n\n    return promise;\n  }\n\n  handleResponse(msg) {\n    const id = msg.id;\n\n    if (this.pendingRequests[id]) {\n      // resolve response\n      if (msg.data === null || msg.data === undefined) {\n        this.pendingRequests[id].reject(new Error(\"Response canceled by responder\"));\n      } else {\n        this.pendingRequests[id].fulfill(decode(msg.data));\n      }\n    } else {\n      console.error(`Got response with no matching request. id=${id}`);\n    }\n  }\n\n  close() {\n    this.socket.close();\n    return this.awaitClose();\n  }\n\n  awaitClose() {\n    return new Promise(resolve => this.socket.on(\"close\", resolve));\n  }\n\n  static connect(url, signalCb) {\n    return new Promise((resolve, reject) => {\n      const socket = new Websocket(url); // make sure that there are no uncaught connection\n      // errors because that causes nodejs thread to crash\n      // with uncaught exception\n\n      socket.onerror = () => {\n        reject(new Error(`could not connect to holochain conductor, please check that a conductor service is running and available at ${url}`));\n      };\n\n      socket.onopen = () => {\n        resolve(new WsClient(socket, signalCb));\n      };\n    });\n  }\n\n}\n\nconst signalTransform = res => {\n  return decode(res);\n};","map":{"version":3,"sources":["/Users/futorine/dev/holochain/holochain-engineers/team-mates/node_modules/@holochain/client/lib/api/client.js"],"names":["decode","encode","Websocket","WsClient","socket","pendingRequests","index","alreadyWarnedNoSignalCb","constructor","signalCb","onmessage","encodedMsg","data","Buffer","isBuffer","arrayBuffer","msg","type","decodedMessage","App","decodedCellId","decodedPayload","signalTransform","signal","cellId","payload","console","log","handleResponse","error","emitSignal","send","request","id","promise","Promise","fulfill","reject","readyState","OPEN","Error","undefined","close","awaitClose","resolve","on","connect","url","onerror","onopen","res"],"mappings":"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","sourcesContent":["import { decode, encode } from \"@msgpack/msgpack\";\nimport Websocket from \"isomorphic-ws\";\n/**\n * A Websocket client which can make requests and receive responses,\n * as well as send and receive signals\n *\n * Uses Holochain's websocket WireMessage for communication.\n */\nexport class WsClient {\n    socket;\n    pendingRequests;\n    index;\n    alreadyWarnedNoSignalCb;\n    constructor(socket, signalCb) {\n        this.socket = socket;\n        this.pendingRequests = {};\n        this.index = 0;\n        // TODO: allow adding signal handlers later\n        this.alreadyWarnedNoSignalCb = false;\n        socket.onmessage = async (encodedMsg) => {\n            let data = encodedMsg.data;\n            // If data is not a buffer (nodejs), it will be a blob (browser)\n            if (typeof Buffer === \"undefined\" || !Buffer.isBuffer(data)) {\n                data = await data.arrayBuffer();\n            }\n            const msg = decode(data);\n            if (msg.type === \"Signal\") {\n                if (signalCb) {\n                    const decodedMessage = decode(msg.data);\n                    if (!decodedMessage.App) {\n                        // We have received a system signal, do nothing\n                        return;\n                    }\n                    // Note: holochain currently returns signals as an array of two values: cellId and the serialized signal payload\n                    // and this array is nested within the App key within the returned message.\n                    const decodedCellId = decodedMessage.App[0];\n                    // Note:In order to return readible content to the UI, the signal payload must also be decoded.\n                    const decodedPayload = signalTransform(decodedMessage.App[1]);\n                    // Return a uniform format to UI (ie: { type, data } - the same format as with callZome and appInfo...)\n                    const signal = {\n                        type: msg.type,\n                        data: { cellId: decodedCellId, payload: decodedPayload },\n                    };\n                    signalCb(signal);\n                }\n                else {\n                    if (!this.alreadyWarnedNoSignalCb)\n                        console.log(\"Received signal but no signal callback was set in constructor\");\n                    this.alreadyWarnedNoSignalCb = true;\n                }\n            }\n            else if (msg.type === \"Response\") {\n                this.handleResponse(msg);\n            }\n            else {\n                console.error(`Got unrecognized Websocket message type: ${msg.type}`);\n            }\n        };\n    }\n    emitSignal(data) {\n        const encodedMsg = encode({\n            type: \"Signal\",\n            data: encode(data),\n        });\n        this.socket.send(encodedMsg);\n    }\n    request(data) {\n        const id = this.index;\n        this.index += 1;\n        const encodedMsg = encode({\n            id,\n            type: \"Request\",\n            data: encode(data),\n        });\n        const promise = new Promise((fulfill, reject) => {\n            this.pendingRequests[id] = { fulfill, reject };\n        });\n        if (this.socket.readyState === this.socket.OPEN) {\n            this.socket.send(encodedMsg);\n        }\n        else {\n            return Promise.reject(new Error(\"Socket is not open\"));\n        }\n        return promise;\n    }\n    handleResponse(msg) {\n        const id = msg.id;\n        if (this.pendingRequests[id]) {\n            // resolve response\n            if (msg.data === null || msg.data === undefined) {\n                this.pendingRequests[id].reject(new Error(\"Response canceled by responder\"));\n            }\n            else {\n                this.pendingRequests[id].fulfill(decode(msg.data));\n            }\n        }\n        else {\n            console.error(`Got response with no matching request. id=${id}`);\n        }\n    }\n    close() {\n        this.socket.close();\n        return this.awaitClose();\n    }\n    awaitClose() {\n        return new Promise((resolve) => this.socket.on(\"close\", resolve));\n    }\n    static connect(url, signalCb) {\n        return new Promise((resolve, reject) => {\n            const socket = new Websocket(url);\n            // make sure that there are no uncaught connection\n            // errors because that causes nodejs thread to crash\n            // with uncaught exception\n            socket.onerror = () => {\n                reject(new Error(`could not connect to holochain conductor, please check that a conductor service is running and available at ${url}`));\n            };\n            socket.onopen = () => {\n                resolve(new WsClient(socket, signalCb));\n            };\n        });\n    }\n}\nconst signalTransform = (res) => {\n    return decode(res);\n};\n"]},"metadata":{},"sourceType":"module"}